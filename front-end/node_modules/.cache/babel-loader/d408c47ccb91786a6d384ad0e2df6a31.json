{"ast":null,"code":"/*\n * Utils functions\n *\n */\nvar crypt = require('crypto');\n/**\n * Break string str each maxLen symbols\n * @param str\n * @param maxLen\n * @returns {string}\n */\n\n\nmodule.exports.linebrk = function (str, maxLen) {\n  var res = '';\n  var i = 0;\n\n  while (i + maxLen < str.length) {\n    res += str.substring(i, i + maxLen) + \"\\n\";\n    i += maxLen;\n  }\n\n  return res + str.substring(i, str.length);\n};\n\nmodule.exports.detectEnvironment = function () {\n  if (typeof window !== 'undefined' && window && !(process && process.title === 'node')) {\n    return 'browser';\n  }\n\n  return 'node';\n};\n/**\n * Trying get a 32-bit unsigned integer from the partial buffer\n * @param buffer\n * @param offset\n * @returns {Number}\n */\n\n\nmodule.exports.get32IntFromBuffer = function (buffer, offset) {\n  offset = offset || 0;\n  var size = 0;\n\n  if ((size = buffer.length - offset) > 0) {\n    if (size >= 4) {\n      return buffer.readUInt32BE(offset);\n    } else {\n      var res = 0;\n\n      for (var i = offset + size, d = 0; i > offset; i--, d += 2) {\n        res += buffer[i - 1] * Math.pow(16, d);\n      }\n\n      return res;\n    }\n  } else {\n    return NaN;\n  }\n};\n\nmodule.exports._ = {\n  isObject: function (value) {\n    var type = typeof value;\n    return !!value && (type == 'object' || type == 'function');\n  },\n  isString: function (value) {\n    return typeof value == 'string' || value instanceof String;\n  },\n  isNumber: function (value) {\n    return typeof value == 'number' || !isNaN(parseFloat(value)) && isFinite(value);\n  },\n\n  /**\n   * Returns copy of `obj` without `removeProp` field.\n   * @param obj\n   * @param removeProp\n   * @returns Object\n   */\n  omit: function (obj, removeProp) {\n    var newObj = {};\n\n    for (var prop in obj) {\n      if (!obj.hasOwnProperty(prop) || prop === removeProp) {\n        continue;\n      }\n\n      newObj[prop] = obj[prop];\n    }\n\n    return newObj;\n  }\n};\n/**\n * Strips everything around the opening and closing lines, including the lines\n * themselves.\n */\n\nmodule.exports.trimSurroundingText = function (data, opening, closing) {\n  var trimStartIndex = 0;\n  var trimEndIndex = data.length;\n  var openingBoundaryIndex = data.indexOf(opening);\n\n  if (openingBoundaryIndex >= 0) {\n    trimStartIndex = openingBoundaryIndex + opening.length;\n  }\n\n  var closingBoundaryIndex = data.indexOf(closing, openingBoundaryIndex);\n\n  if (closingBoundaryIndex >= 0) {\n    trimEndIndex = closingBoundaryIndex;\n  }\n\n  return data.substring(trimStartIndex, trimEndIndex);\n};","map":null,"metadata":{},"sourceType":"script"}