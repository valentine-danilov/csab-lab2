{"ast":null,"code":"/*!\n * RSA library for Node.js\n *\n * Author: rzcoder\n * License MIT\n */\nvar constants = require('constants');\n\nvar rsa = require('./libs/rsa.js');\n\nvar crypt = require('crypto');\n\nvar ber = require('asn1').Ber;\n\nvar _ = require('./utils')._;\n\nvar utils = require('./utils');\n\nvar schemes = require('./schemes/schemes.js');\n\nvar formats = require('./formats/formats.js');\n\nif (typeof constants.RSA_NO_PADDING === \"undefined\") {\n  //patch for node v0.10.x, constants do not defined\n  constants.RSA_NO_PADDING = 3;\n}\n\nmodule.exports = function () {\n  var SUPPORTED_HASH_ALGORITHMS = {\n    node10: ['md4', 'md5', 'ripemd160', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n    node: ['md4', 'md5', 'ripemd160', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n    iojs: ['md4', 'md5', 'ripemd160', 'sha1', 'sha224', 'sha256', 'sha384', 'sha512'],\n    browser: ['md5', 'ripemd160', 'sha1', 'sha256', 'sha512']\n  };\n  var DEFAULT_ENCRYPTION_SCHEME = 'pkcs1_oaep';\n  var DEFAULT_SIGNING_SCHEME = 'pkcs1';\n  var DEFAULT_EXPORT_FORMAT = 'private';\n  var EXPORT_FORMAT_ALIASES = {\n    'private': 'pkcs1-private-pem',\n    'private-der': 'pkcs1-private-der',\n    'public': 'pkcs8-public-pem',\n    'public-der': 'pkcs8-public-der'\n  };\n  /**\n   * @param key {string|buffer|object} Key in PEM format, or data for generate key {b: bits, e: exponent}\n   * @constructor\n   */\n\n  function NodeRSA(key, format, options) {\n    if (!(this instanceof NodeRSA)) {\n      return new NodeRSA(key, format, options);\n    }\n\n    if (_.isObject(format)) {\n      options = format;\n      format = undefined;\n    }\n\n    this.$options = {\n      signingScheme: DEFAULT_SIGNING_SCHEME,\n      signingSchemeOptions: {\n        hash: 'sha256',\n        saltLength: null\n      },\n      encryptionScheme: DEFAULT_ENCRYPTION_SCHEME,\n      encryptionSchemeOptions: {\n        hash: 'sha1',\n        label: null\n      },\n      environment: utils.detectEnvironment(),\n      rsaUtils: this\n    };\n    this.keyPair = new rsa.Key();\n    this.$cache = {};\n\n    if (Buffer.isBuffer(key) || _.isString(key)) {\n      this.importKey(key, format);\n    } else if (_.isObject(key)) {\n      this.generateKeyPair(key.b, key.e);\n    }\n\n    this.setOptions(options);\n  }\n  /**\n   * Set and validate options for key instance\n   * @param options\n   */\n\n\n  NodeRSA.prototype.setOptions = function (options) {\n    options = options || {};\n\n    if (options.environment) {\n      this.$options.environment = options.environment;\n    }\n\n    if (options.signingScheme) {\n      if (_.isString(options.signingScheme)) {\n        var signingScheme = options.signingScheme.toLowerCase().split('-');\n\n        if (signingScheme.length == 1) {\n          if (SUPPORTED_HASH_ALGORITHMS.node.indexOf(signingScheme[0]) > -1) {\n            this.$options.signingSchemeOptions = {\n              hash: signingScheme[0]\n            };\n            this.$options.signingScheme = DEFAULT_SIGNING_SCHEME;\n          } else {\n            this.$options.signingScheme = signingScheme[0];\n            this.$options.signingSchemeOptions = {\n              hash: null\n            };\n          }\n        } else {\n          this.$options.signingSchemeOptions = {\n            hash: signingScheme[1]\n          };\n          this.$options.signingScheme = signingScheme[0];\n        }\n      } else if (_.isObject(options.signingScheme)) {\n        this.$options.signingScheme = options.signingScheme.scheme || DEFAULT_SIGNING_SCHEME;\n        this.$options.signingSchemeOptions = _.omit(options.signingScheme, 'scheme');\n      }\n\n      if (!schemes.isSignature(this.$options.signingScheme)) {\n        throw Error('Unsupported signing scheme');\n      }\n\n      if (this.$options.signingSchemeOptions.hash && SUPPORTED_HASH_ALGORITHMS[this.$options.environment].indexOf(this.$options.signingSchemeOptions.hash) === -1) {\n        throw Error('Unsupported hashing algorithm for ' + this.$options.environment + ' environment');\n      }\n    }\n\n    if (options.encryptionScheme) {\n      if (_.isString(options.encryptionScheme)) {\n        this.$options.encryptionScheme = options.encryptionScheme.toLowerCase();\n        this.$options.encryptionSchemeOptions = {};\n      } else if (_.isObject(options.encryptionScheme)) {\n        this.$options.encryptionScheme = options.encryptionScheme.scheme || DEFAULT_ENCRYPTION_SCHEME;\n        this.$options.encryptionSchemeOptions = _.omit(options.encryptionScheme, 'scheme');\n      }\n\n      if (!schemes.isEncryption(this.$options.encryptionScheme)) {\n        throw Error('Unsupported encryption scheme');\n      }\n\n      if (this.$options.encryptionSchemeOptions.hash && SUPPORTED_HASH_ALGORITHMS[this.$options.environment].indexOf(this.$options.encryptionSchemeOptions.hash) === -1) {\n        throw Error('Unsupported hashing algorithm for ' + this.$options.environment + ' environment');\n      }\n    }\n\n    this.keyPair.setOptions(this.$options);\n  };\n  /**\n   * Generate private/public keys pair\n   *\n   * @param bits {int} length key in bits. Default 2048.\n   * @param exp {int} public exponent. Default 65537.\n   * @returns {NodeRSA}\n   */\n\n\n  NodeRSA.prototype.generateKeyPair = function (bits, exp) {\n    bits = bits || 2048;\n    exp = exp || 65537;\n\n    if (bits % 8 !== 0) {\n      throw Error('Key size must be a multiple of 8.');\n    }\n\n    this.keyPair.generate(bits, exp.toString(16));\n    this.$cache = {};\n    return this;\n  };\n  /**\n   * Importing key\n   * @param keyData {string|buffer|Object}\n   * @param format {string}\n   */\n\n\n  NodeRSA.prototype.importKey = function (keyData, format) {\n    if (!keyData) {\n      throw Error(\"Empty key given\");\n    }\n\n    if (format) {\n      format = EXPORT_FORMAT_ALIASES[format] || format;\n    }\n\n    if (!formats.detectAndImport(this.keyPair, keyData, format) && format === undefined) {\n      throw Error(\"Key format must be specified\");\n    }\n\n    this.$cache = {};\n    return this;\n  };\n  /**\n   * Exporting key\n   * @param [format] {string}\n   */\n\n\n  NodeRSA.prototype.exportKey = function (format) {\n    format = format || DEFAULT_EXPORT_FORMAT;\n    format = EXPORT_FORMAT_ALIASES[format] || format;\n\n    if (!this.$cache[format]) {\n      this.$cache[format] = formats.detectAndExport(this.keyPair, format);\n    }\n\n    return this.$cache[format];\n  };\n  /**\n   * Check if key pair contains private key\n   */\n\n\n  NodeRSA.prototype.isPrivate = function () {\n    return this.keyPair.isPrivate();\n  };\n  /**\n   * Check if key pair contains public key\n   * @param [strict] {boolean} - public key only, return false if have private exponent\n   */\n\n\n  NodeRSA.prototype.isPublic = function (strict) {\n    return this.keyPair.isPublic(strict);\n  };\n  /**\n   * Check if key pair doesn't contains any data\n   */\n\n\n  NodeRSA.prototype.isEmpty = function (strict) {\n    return !(this.keyPair.n || this.keyPair.e || this.keyPair.d);\n  };\n  /**\n   * Encrypting data method with public key\n   *\n   * @param buffer {string|number|object|array|Buffer} - data for encrypting. Object and array will convert to JSON string.\n   * @param encoding {string} - optional. Encoding for output result, may be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.\n   * @param source_encoding {string} - optional. Encoding for given string. Default utf8.\n   * @returns {string|Buffer}\n   */\n\n\n  NodeRSA.prototype.encrypt = function (buffer, encoding, source_encoding) {\n    return this.$$encryptKey(false, buffer, encoding, source_encoding);\n  };\n  /**\n   * Decrypting data method with private key\n   *\n   * @param buffer {Buffer} - buffer for decrypting\n   * @param encoding - encoding for result string, can also take 'json' or 'buffer' for the automatic conversion of this type\n   * @returns {Buffer|object|string}\n   */\n\n\n  NodeRSA.prototype.decrypt = function (buffer, encoding) {\n    return this.$$decryptKey(false, buffer, encoding);\n  };\n  /**\n   * Encrypting data method with private key\n   *\n   * Parameters same as `encrypt` method\n   */\n\n\n  NodeRSA.prototype.encryptPrivate = function (buffer, encoding, source_encoding) {\n    return this.$$encryptKey(true, buffer, encoding, source_encoding);\n  };\n  /**\n   * Decrypting data method with public key\n   *\n   * Parameters same as `decrypt` method\n   */\n\n\n  NodeRSA.prototype.decryptPublic = function (buffer, encoding) {\n    return this.$$decryptKey(true, buffer, encoding);\n  };\n  /**\n   * Encrypting data method with custom key\n   */\n\n\n  NodeRSA.prototype.$$encryptKey = function (usePrivate, buffer, encoding, source_encoding) {\n    try {\n      var res = this.keyPair.encrypt(this.$getDataForEncrypt(buffer, source_encoding), usePrivate);\n\n      if (encoding == 'buffer' || !encoding) {\n        return res;\n      } else {\n        return res.toString(encoding);\n      }\n    } catch (e) {\n      throw Error('Error during encryption. Original error: ' + e);\n    }\n  };\n  /**\n   * Decrypting data method with custom key\n   */\n\n\n  NodeRSA.prototype.$$decryptKey = function (usePublic, buffer, encoding) {\n    try {\n      buffer = _.isString(buffer) ? Buffer.from(buffer, 'base64') : buffer;\n      var res = this.keyPair.decrypt(buffer, usePublic);\n\n      if (res === null) {\n        throw Error('Key decrypt method returns null.');\n      }\n\n      return this.$getDecryptedData(res, encoding);\n    } catch (e) {\n      throw Error('Error during decryption (probably incorrect key). Original error: ' + e);\n    }\n  };\n  /**\n   *  Signing data\n   *\n   * @param buffer {string|number|object|array|Buffer} - data for signing. Object and array will convert to JSON string.\n   * @param encoding {string} - optional. Encoding for output result, may be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.\n   * @param source_encoding {string} - optional. Encoding for given string. Default utf8.\n   * @returns {string|Buffer}\n   */\n\n\n  NodeRSA.prototype.sign = function (buffer, encoding, source_encoding) {\n    if (!this.isPrivate()) {\n      throw Error(\"This is not private key\");\n    }\n\n    var res = this.keyPair.sign(this.$getDataForEncrypt(buffer, source_encoding));\n\n    if (encoding && encoding != 'buffer') {\n      res = res.toString(encoding);\n    }\n\n    return res;\n  };\n  /**\n   *  Verifying signed data\n   *\n   * @param buffer - signed data\n   * @param signature\n   * @param source_encoding {string} - optional. Encoding for given string. Default utf8.\n   * @param signature_encoding - optional. Encoding of given signature. May be 'buffer', 'binary', 'hex' or 'base64'. Default 'buffer'.\n   * @returns {*}\n   */\n\n\n  NodeRSA.prototype.verify = function (buffer, signature, source_encoding, signature_encoding) {\n    if (!this.isPublic()) {\n      throw Error(\"This is not public key\");\n    }\n\n    signature_encoding = !signature_encoding || signature_encoding == 'buffer' ? null : signature_encoding;\n    return this.keyPair.verify(this.$getDataForEncrypt(buffer, source_encoding), signature, signature_encoding);\n  };\n  /**\n   * Returns key size in bits\n   * @returns {int}\n   */\n\n\n  NodeRSA.prototype.getKeySize = function () {\n    return this.keyPair.keySize;\n  };\n  /**\n   * Returns max message length in bytes (for 1 chunk) depending on current encryption scheme\n   * @returns {int}\n   */\n\n\n  NodeRSA.prototype.getMaxMessageSize = function () {\n    return this.keyPair.maxMessageLength;\n  };\n  /**\n   * Preparing given data for encrypting/signing. Just make new/return Buffer object.\n   *\n   * @param buffer {string|number|object|array|Buffer} - data for encrypting. Object and array will convert to JSON string.\n   * @param encoding {string} - optional. Encoding for given string. Default utf8.\n   * @returns {Buffer}\n   */\n\n\n  NodeRSA.prototype.$getDataForEncrypt = function (buffer, encoding) {\n    if (_.isString(buffer) || _.isNumber(buffer)) {\n      return Buffer.from('' + buffer, encoding || 'utf8');\n    } else if (Buffer.isBuffer(buffer)) {\n      return buffer;\n    } else if (_.isObject(buffer)) {\n      return Buffer.from(JSON.stringify(buffer));\n    } else {\n      throw Error(\"Unexpected data type\");\n    }\n  };\n  /**\n   *\n   * @param buffer {Buffer} - decrypted data.\n   * @param encoding - optional. Encoding for result output. May be 'buffer', 'json' or any of Node.js Buffer supported encoding.\n   * @returns {*}\n   */\n\n\n  NodeRSA.prototype.$getDecryptedData = function (buffer, encoding) {\n    encoding = encoding || 'buffer';\n\n    if (encoding == 'buffer') {\n      return buffer;\n    } else if (encoding == 'json') {\n      return JSON.parse(buffer.toString());\n    } else {\n      return buffer.toString(encoding);\n    }\n  };\n\n  return NodeRSA;\n}();","map":null,"metadata":{},"sourceType":"script"}