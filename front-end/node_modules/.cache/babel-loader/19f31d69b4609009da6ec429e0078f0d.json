{"ast":null,"code":"/**\n * PKCS1 padding and signature scheme\n */\nvar BigInteger = require('../libs/jsbn');\n\nvar crypt = require('crypto');\n\nvar constants = require('constants');\n\nvar SIGN_INFO_HEAD = {\n  md2: Buffer.from('3020300c06082a864886f70d020205000410', 'hex'),\n  md5: Buffer.from('3020300c06082a864886f70d020505000410', 'hex'),\n  sha1: Buffer.from('3021300906052b0e03021a05000414', 'hex'),\n  sha224: Buffer.from('302d300d06096086480165030402040500041c', 'hex'),\n  sha256: Buffer.from('3031300d060960864801650304020105000420', 'hex'),\n  sha384: Buffer.from('3041300d060960864801650304020205000430', 'hex'),\n  sha512: Buffer.from('3051300d060960864801650304020305000440', 'hex'),\n  ripemd160: Buffer.from('3021300906052b2403020105000414', 'hex'),\n  rmd160: Buffer.from('3021300906052b2403020105000414', 'hex')\n};\nvar SIGN_ALG_TO_HASH_ALIASES = {\n  'ripemd160': 'rmd160'\n};\nvar DEFAULT_HASH_FUNCTION = 'sha256';\nmodule.exports = {\n  isEncryption: true,\n  isSignature: true\n};\n\nmodule.exports.makeScheme = function (key, options) {\n  function Scheme(key, options) {\n    this.key = key;\n    this.options = options;\n  }\n\n  Scheme.prototype.maxMessageLength = function () {\n    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n      return this.key.encryptedDataLength;\n    }\n\n    return this.key.encryptedDataLength - 11;\n  };\n  /**\n   * Pad input Buffer to encryptedDataLength bytes, and return Buffer.from\n   * alg: PKCS#1\n   * @param buffer\n   * @returns {Buffer}\n   */\n\n\n  Scheme.prototype.encPad = function (buffer, options) {\n    options = options || {};\n    var filled;\n\n    if (buffer.length > this.key.maxMessageLength) {\n      throw new Error(\"Message too long for RSA (n=\" + this.key.encryptedDataLength + \", l=\" + buffer.length + \")\");\n    }\n\n    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n      //RSA_NO_PADDING treated like JAVA left pad with zero character\n      filled = Buffer.alloc(this.key.maxMessageLength - buffer.length);\n      filled.fill(0);\n      return Buffer.concat([filled, buffer]);\n    }\n    /* Type 1: zeros padding for private key encrypt */\n\n\n    if (options.type === 1) {\n      filled = Buffer.alloc(this.key.encryptedDataLength - buffer.length - 1);\n      filled.fill(0xff, 0, filled.length - 1);\n      filled[0] = 1;\n      filled[filled.length - 1] = 0;\n      return Buffer.concat([filled, buffer]);\n    } else {\n      /* random padding for public key encrypt */\n      filled = Buffer.alloc(this.key.encryptedDataLength - buffer.length);\n      filled[0] = 0;\n      filled[1] = 2;\n      var rand = crypt.randomBytes(filled.length - 3);\n\n      for (var i = 0; i < rand.length; i++) {\n        var r = rand[i];\n\n        while (r === 0) {\n          // non-zero only\n          r = crypt.randomBytes(1)[0];\n        }\n\n        filled[i + 2] = r;\n      }\n\n      filled[filled.length - 1] = 0;\n      return Buffer.concat([filled, buffer]);\n    }\n  };\n  /**\n   * Unpad input Buffer and, if valid, return the Buffer object\n   * alg: PKCS#1 (type 2, random)\n   * @param buffer\n   * @returns {Buffer}\n   */\n\n\n  Scheme.prototype.encUnPad = function (buffer, options) {\n    options = options || {};\n    var i = 0;\n\n    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n      //RSA_NO_PADDING treated like JAVA left pad with zero character\n      var unPad;\n\n      if (typeof buffer.lastIndexOf == \"function\") {\n        //patch for old node version\n        unPad = buffer.slice(buffer.lastIndexOf('\\0') + 1, buffer.length);\n      } else {\n        unPad = buffer.slice(String.prototype.lastIndexOf.call(buffer, '\\0') + 1, buffer.length);\n      }\n\n      return unPad;\n    }\n\n    if (buffer.length < 4) {\n      return null;\n    }\n    /* Type 1: zeros padding for private key decrypt */\n\n\n    if (options.type === 1) {\n      if (buffer[0] !== 0 || buffer[1] !== 1) {\n        return null;\n      }\n\n      i = 3;\n\n      while (buffer[i] !== 0) {\n        if (buffer[i] != 0xFF || ++i >= buffer.length) {\n          return null;\n        }\n      }\n    } else {\n      /* random padding for public key decrypt */\n      if (buffer[0] !== 0 || buffer[1] !== 2) {\n        return null;\n      }\n\n      i = 3;\n\n      while (buffer[i] !== 0) {\n        if (++i >= buffer.length) {\n          return null;\n        }\n      }\n    }\n\n    return buffer.slice(i + 1, buffer.length);\n  };\n\n  Scheme.prototype.sign = function (buffer) {\n    var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n\n    if (this.options.environment === 'browser') {\n      hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;\n      var hasher = crypt.createHash(hashAlgorithm);\n      hasher.update(buffer);\n      var hash = this.pkcs1pad(hasher.digest(), hashAlgorithm);\n      var res = this.key.$doPrivate(new BigInteger(hash)).toBuffer(this.key.encryptedDataLength);\n      return res;\n    } else {\n      var signer = crypt.createSign('RSA-' + hashAlgorithm.toUpperCase());\n      signer.update(buffer);\n      return signer.sign(this.options.rsaUtils.exportKey('private'));\n    }\n  };\n\n  Scheme.prototype.verify = function (buffer, signature, signature_encoding) {\n    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == constants.RSA_NO_PADDING) {\n      //RSA_NO_PADDING has no verify data\n      return false;\n    }\n\n    var hashAlgorithm = this.options.signingSchemeOptions.hash || DEFAULT_HASH_FUNCTION;\n\n    if (this.options.environment === 'browser') {\n      hashAlgorithm = SIGN_ALG_TO_HASH_ALIASES[hashAlgorithm] || hashAlgorithm;\n\n      if (signature_encoding) {\n        signature = Buffer.from(signature, signature_encoding);\n      }\n\n      var hasher = crypt.createHash(hashAlgorithm);\n      hasher.update(buffer);\n      var hash = this.pkcs1pad(hasher.digest(), hashAlgorithm);\n      var m = this.key.$doPublic(new BigInteger(signature));\n      return m.toBuffer().toString('hex') == hash.toString('hex');\n    } else {\n      var verifier = crypt.createVerify('RSA-' + hashAlgorithm.toUpperCase());\n      verifier.update(buffer);\n      return verifier.verify(this.options.rsaUtils.exportKey('public'), signature, signature_encoding);\n    }\n  };\n  /**\n   * PKCS#1 zero pad input buffer to max data length\n   * @param hashBuf\n   * @param hashAlgorithm\n   * @returns {*}\n   */\n\n\n  Scheme.prototype.pkcs0pad = function (buffer) {\n    var filled = Buffer.alloc(this.key.maxMessageLength - buffer.length);\n    filled.fill(0);\n    return Buffer.concat([filled, buffer]);\n  };\n\n  Scheme.prototype.pkcs0unpad = function (buffer) {\n    var unPad;\n\n    if (typeof buffer.lastIndexOf == \"function\") {\n      //patch for old node version\n      unPad = buffer.slice(buffer.lastIndexOf('\\0') + 1, buffer.length);\n    } else {\n      unPad = buffer.slice(String.prototype.lastIndexOf.call(buffer, '\\0') + 1, buffer.length);\n    }\n\n    return unPad;\n  };\n  /**\n   * PKCS#1 pad input buffer to max data length\n   * @param hashBuf\n   * @param hashAlgorithm\n   * @returns {*}\n   */\n\n\n  Scheme.prototype.pkcs1pad = function (hashBuf, hashAlgorithm) {\n    var digest = SIGN_INFO_HEAD[hashAlgorithm];\n\n    if (!digest) {\n      throw Error('Unsupported hash algorithm');\n    }\n\n    var data = Buffer.concat([digest, hashBuf]);\n\n    if (data.length + 10 > this.key.encryptedDataLength) {\n      throw Error('Key is too short for signing algorithm (' + hashAlgorithm + ')');\n    }\n\n    var filled = Buffer.alloc(this.key.encryptedDataLength - data.length - 1);\n    filled.fill(0xff, 0, filled.length - 1);\n    filled[0] = 1;\n    filled[filled.length - 1] = 0;\n    var res = Buffer.concat([filled, data]);\n    return res;\n  };\n\n  return new Scheme(key, options);\n};","map":null,"metadata":{},"sourceType":"script"}